from __future__ import annotations

from collections.abc import Callable, Iterable
from typing import Generic, Never, TypeAlias, TypeVar, overload

__all__: list[str] = ["Predicate"]

T = TypeVar("T")
U = TypeVar("U")
Obj = TypeVar("Obj", bound=object)

ExceptionFactory: TypeAlias = Callable[[str, U, str], type[BaseException]]

class Predicate(Generic[T]):
    __slots__: tuple[str, ...]

    @overload
    def __init__(self, func: Callable[[T], bool], /, name: str, msg: str) -> None: ...
    @overload
    def __init__(
        self, func: Callable[[T], bool], /, name: str, msg: Callable[[T | None], str]
    ) -> None: ...
    @overload
    def __init__(
        self, func: Callable[[T], bool], /, name: str, msg: None = None
    ) -> None: ...
    def __call__(self, x: T) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def msg(self) -> str | Callable[[T | None], str]: ...
    @overload
    def render_msg(self, x: T, /) -> str: ...
    @overload
    def render_msg(self, x: None = None, /) -> str: ...
    @overload
    def render_with_context(self, x: T, /, *, max_chain: int = 6) -> str: ...
    @overload
    def render_with_context(self, x: None = None, /, *, max_chain: int = 6) -> str: ...
    @overload
    def render_tree(self, x: T, /) -> str: ...
    @overload
    def render_tree(self, x: None = None, /) -> str: ...
    def explain(self, x: T) -> str | None: ...
    @overload
    def validate(
        self, x: T, /, *, label: str = "value", exc: type[BaseException] = ValueError
    ) -> T: ...
    @overload
    def validate(
        self,
        x: T,
        /,
        *,
        label: str = "value",
        exc: ExceptionFactory[T],
    ) -> T: ...
    def with_name(self, name: str) -> Predicate[T]: ...
    @overload
    def with_msg(self, msg: str) -> Predicate[T]: ...
    @overload
    def with_msg(self, msg: Callable[[T | None], str]) -> Predicate[T]: ...
    def __and__(self, other: Predicate[T]) -> Predicate[T]: ...
    def __rand__(self, other: Predicate[T]) -> Predicate[T]: ...
    def __or__(self, other: Predicate[T]) -> Predicate[T]: ...
    def __ror__(self, other: Predicate[T]) -> Predicate[T]: ...
    def __invert__(self) -> Predicate[T]: ...
    def negate(self) -> Predicate[T]: ...
    def __xor__(self, other: Predicate[T]) -> Predicate[T]: ...
    def __rxor__(self, other: Predicate[T]) -> Predicate[T]: ...
    def xor(self, other: Predicate[T]) -> Predicate[T]: ...
    def implies(self, other: Predicate[T]) -> Predicate[T]: ...
    @overload
    def lift(
        self,
        func: Callable[[T], bool],
        /,
        name: str | None,
        msg: str | Callable[[T | None], str],
    ) -> Predicate[T]: ...
    @overload
    def lift(
        self,
        func: Callable[[U], bool],
        /,
        name: str | None,
        msg: str | Callable[[U | None], str],
    ) -> Predicate[U]: ...
    def clone(
        self,
        *,
        name: str | None = None,
        msg: str | Callable[[T | None], str] | None = None,
    ) -> Predicate[T]: ...
    def on(
        self,
        getter: Callable[[Obj], T],
        /,
    ) -> Predicate[Obj]: ...
    def quantify(
        self,
        quantifier: Callable[[Iterable[bool]], bool],
        /,
        label: str,
        *,
        prefix: str,
    ) -> Predicate[Iterable[T]]: ...
    def all(self) -> Predicate[Iterable[T]]: ...
    def any(self) -> Predicate[Iterable[T]]: ...
    def at_least(self, n: int) -> Predicate[Iterable[T]]: ...
    def at_most(self, n: int) -> Predicate[Iterable[T]]: ...
    def exactly(self, n: int) -> Predicate[Iterable[T]]: ...
    def __bool__(self) -> Never: ...
    def __repr__(self) -> str: ...
